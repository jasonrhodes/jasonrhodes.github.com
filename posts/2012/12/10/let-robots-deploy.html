<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="description" content="Humanistic grokblogging { javascript + other shiny things }">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <title>Let the robots deploy your code | Not Robotic</title>
  <link rel="stylesheet" href="/assets/style.css" />
</head>
<body>
<div class="header">
  <div class="center">
    <a class="site-title" href="/"><span class="not">not</span> <span class="robotic">robotic</span></a>
    <p class="site-description">Humanistic grokblogging { javascript + other shiny things }</p>
    <!--
    <div class="mobile-menu">
      <a href="#menu"><i class="fa fa-bars"></i></a>
      <a href="/rss"><i class="fa fa-rss"></i></a>
    </div>
    -->
  </div>
</div>

<div class="single post entry center">
  <h1 class="entry-title">Let the robots deploy your code</h1>
  <h2 class="entry-subheading"></h2>
  <p class="entry-date"><b>December 10th, 2012</b> by <b><a href="/about">Jason</a></b></p>
  <div class="entry-content">
    <p>I used to have a well-rehearsed routine that you might recognize.</p>
<ol>
<li>Open “Coda” or a similar FTP-coupled editor</li>
<li>Reverse publish from the remote server</li>
<li>Make changes to the file(s) locally</li>
<li>Mark a set of files for publishing from my local machine</li>
<li>Make sure that if I haven’t properly set up the remote and local folders for this project (and I was never really sure that I had), that I’m in the right directory in both locations manually</li>
<li>Publish the marked files</li>
<li>Pray that I didn’t overwrite anything that I didn’t mean to overwrite</li>
</ol>
<p>Sometimes I would mix in a few steps like “<em>Forget which server has the most up to date files, then inspect each one line by line and try to figure out which is the right one</em>“ or “<em>Overwrite 3 weeks of changes by pulling down an old copy of code and overwriting my local copy by accident</em>“.</p>
<p>What a rush!</p>
<p>Learning version control solved some of the pain of accidental overwrites, etc. But even after we got into a good version control workflow (we use git and Github at Johns Hopkins), deployment was still pretty manual for a while. Now, it looked like</p>
<ol>
<li><code>$ scp</code> the folder into a <code>tmp</code> directory on the staging or production server</li>
<li>[<em>do things on the remote server via ssh</em>]</li>
<li>Move the current code out of the main folder and into some backup folder, maybe, or just remove it entirely</li>
<li>Move the new code into the main folder <em>as fast as possible</em> to minimize downtime</li>
</ol>
<p>There were a lot of reasons why this process sucked. But really, this is a repetitive list of really important tasks, and it’s the kind of thing that we humans suck at and that a robot goes <em>GA GA</em> over. And since we’re definitely not robotic <a href="https://gimmebar.com/view/50c74599aac422ce14000000">(wink, wink)</a>, why waste so much time on such a robot-friendly job?</p>
<p>[Enter <em>Capistrano</em>]</p>
<p>I first heard of Capistrano from the Ruby clans who were all using it for deploying their Rails to-do apps. I assumed, like you might, that it wouldn’t work for PHP projects, but if you can get Ruby installed on your local machine and you have SSH access to the remote servers, that’s all you really need, especially if the project is hosted on Github (even a private repo). After a small amount of Ruby version-related setup pain, our deployment process became:</p>
<pre><code class="lang-bash">$ cap (environment) deploy
</code></pre>
<p>Interested?</p>
<h3 id="if-you-have-ssh-access-use-capistrano">If you have ssh access, use Capistrano</h3>
<p>Here’s the basic runthrough of what Capistrano does: connect to a remote server via ssh, cd into the project folder, clone from the repo/branch you designate into a folder named as a unix timestamp, run through a series of tasks that you designate, points the symlink of “[project]/current” to the new timestamped directory. Rolling back, or <code>$ cap rollback</code>, just points the symlink back and removes the latest directory. And the site’s virtual host just has to be adjusted to point to [project]/current/public or whatever.</p>
<p>The traditional Cap setup is just a <code>Capfile</code> (think Makefile, Gemfile, etc) in your project root alongside <code>config/deploy.rb</code>. The settings are almost all self-explanatory and easy to adapt for your own setup. And if you need to deploy to multiple environments, like we do, that’s easy too. There’s <a href="https://github.com/capistrano/capistrano/wiki/2.x-Multistage-Extension">a gem called multistage</a> that changes the deploy.rb file into a deploy directory, with [environment].rb files inside. We have config/deploy/staging.rb and config/deploy/production.rb, with environment-specific settings in each.</p>
<p>We default the deploy command to our staging environment, so deploying to staging is really just <code>$ cap deploy</code> and deploying to production is <code>$ cap production deploy</code>. Once everything is automated, you can build in some pretty neat tricks and defaults, too. </p>
<p>For instance, one of the settings you set is which branch to deploy from. In staging.rb, we set it like this:</p>
<pre><code class="lang-ruby">set <span class="hljs-symbol">:branch</span>, <span class="hljs-variable">$1</span> <span class="hljs-keyword">if</span> `git branch` =~ <span class="hljs-regexp">/\* (\S+)\s/m</span> <span class="hljs-comment"># "master"</span>
</code></pre>
<p>It prints out the branches and regex selects the branch with an “*”, so you can easily deploy from whichever branch you happen to be on (make sure it’s pushed to github!). But in production.rb, we just use:</p>
<pre><code class="lang-ruby">set <span class="hljs-symbol">:branch</span>, <span class="hljs-string">"master"</span>
</code></pre>
<p>Which keeps us from ever mistakenly deploying to production from any branch but master. Robots keep us safe. And because one of our databases is currently a Drupal database, we have a series of Drupal-related tasks we’d like to run through on every deploy. Writing your own custom tasks is pretty easy once you get familiar with the DSL. A sampling of our Drupal tasks:</p>
<pre><code class="lang-ruby">namespace <span class="hljs-symbol">:drupal</span> <span class="hljs-keyword">do</span>

  <span class="hljs-comment"># Clear all caches</span>
  task <span class="hljs-symbol">:clear_caches</span> <span class="hljs-keyword">do</span> 
    run <span class="hljs-string">"cd <span class="hljs-subst">#{latest_release}</span>/public/factory &amp;&amp; drush cc all"</span>
  <span class="hljs-keyword">end</span>

  <span class="hljs-comment"># revert all features</span>
  task <span class="hljs-symbol">:features_revert</span> <span class="hljs-keyword">do</span>
    run <span class="hljs-string">"cd <span class="hljs-subst">#{latest_release}</span>/public/factory &amp;&amp; drush fr-all"</span>
  <span class="hljs-keyword">end</span>    

  <span class="hljs-comment"># shared directories</span>
  task <span class="hljs-symbol">:setup</span> <span class="hljs-keyword">do</span>
    run <span class="hljs-string">"mkdir -p <span class="hljs-subst">#{shared_path}</span>/files"</span>
    run <span class="hljs-string">"chown -R <span class="hljs-subst">#{user}</span>:web <span class="hljs-subst">#{deploy_to}</span>"</span>
  <span class="hljs-keyword">end</span>

  <span class="hljs-comment"># ... etc</span>

<span class="hljs-keyword">end</span>
</code></pre>
<p>Adding these tasks into the deployment flow is also pretty easy.</p>
<pre><code class="lang-ruby">after <span class="hljs-string">"deploy:setup"</span>, <span class="hljs-string">"drupal:setup"</span>
after <span class="hljs-string">"deploy:create_symlink"</span>, <span class="hljs-string">"drupal:clear_caches"</span>
<span class="hljs-comment"># etc</span>
</code></pre>
<p>Or you can call a task manually from your local machine, like <code>$ cap drupal:features_revert</code> to abstract the ssh file system navigation, or group together a bunch of steps into one easy command you run from time to time.</p>
<p>Capistrano is also great for managing Composer, if you add the vendor file to your .gitignore and let your remote servers install dependencies on each deployment.</p>
<pre><code class="lang-ruby">task <span class="hljs-symbol">:update_dependencies</span> <span class="hljs-keyword">do</span> 
  <span class="hljs-comment"># Uses composer to update dependencies into the vendor/ directory</span>
  run <span class="hljs-string">"cd <span class="hljs-subst">#{current_release}</span> &amp;&amp; php composer.phar update"</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>If you have SSH access to your remote servers, Capistrano will change your deployment life. But what if you’re stuck on a shared host that doesn’t allow good SSH access? Back to FTP copy and paste hell? That’s what I thought for a long time, when I would come home at night and work on smaller freelance projects, and it made me cry.</p>
<p>And then I discovered git-ftp.</p>
<h3 id="if-you-only-have-ftp-access-use-git-ftp">If you only have FTP access, use git-ftp</h3>
<p><a href="https://github.com/resmo/git-ftp">git-ftp</a> isn’t going to let you automate extra deployment tasks, or protect you from deploying from the wrong branch. Capistrano is way better if you can use it. But if you can’t, you still want to avoid manually copying and pasting files over FTP if you value your life and sanity. Once you’ve initialized a git repo in your project and have git-ftp installed on your machine, you can set it up quickly.</p>
<pre><code class="lang-bash">$ git config git-ftp.user jason
$ git config git-ftp.url ftp.mysite.com
$ git config git-ftp.password password1234 <span class="hljs-comment"># kids love this password</span>
</code></pre>
<p>You can easily point it to a subfolder of the ftp site, too, using ftp.mysite.com/public_html/mysubfolder, if you need to. Then, once you commit your changes, you just git ftp them up.</p>
<pre><code class="lang-bash"><span class="hljs-comment"># The first time</span>
$ git ftp init

<span class="hljs-comment"># Every other time, it just pushes the diff</span>
$ git ftp push
</code></pre>
<p>Quick, smart deployment for an FTP project. </p>
<p><strong>Some resources</strong></p>
<ul>
<li><a href="http://ryanbigg.com/2011/06/mac-os-x-ruby-rvm-rails-and-you/">Mac OS X, Ruby, RVM, Rails and You</a></li>
<li><a href="http://stackoverflow.com/questions/8032824/cant-install-ruby-under-lion-with-rvm-gcc-issues">Ruby and GCC issues on Mac OS X</a></li>
<li><a href="http://rubyinstaller.org/">Ruby installer for Windows</a></li>
<li><a href="https://github.com/capistrano/capistrano/wiki/2.x-Getting-Started">“Getting Started” with Capistrano documentation</a></li>
<li><a href="https://github.com/resmo/git-ftp">git-ftp</a></li>
</ul>


    <p class="posts-home"><a href="/"><i class="fa fa-home"></i> Posts Home</a></p>
  </div>
</div>

<script type="text/javascript" src="/assets/main.js"></script>
</body>
</html>